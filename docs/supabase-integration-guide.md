# PsyPlex Supabase Database Integration Guide

## Overview

This comprehensive guide explains how Supabase is integrated into the PsyPlex application as the database backend for storing and retrieving therapy session data, particularly focused on Gemini AI processed outputs.

## Architecture Overview

PsyPlex uses a hybrid backend architecture:

- **Authentication & Business Logic**: Handled by a FastAPI backend server
- **Database Operations**: Direct client-to-database operations via Supabase client
- **Data Processing**: Gemini AI for processing therapy session recordings

## Setup Instructions

### 1. Environment Configuration

Your `.env` file in the project root must include these variables:

```
VITE_SUPABASE_URL=your-supabase-project-url
VITE_SUPABASE_ANON_KEY=your-supabase-anon-key
VITE_API_URL=http://localhost:8000  # Your FastAPI backend URL
```

These environment variables are accessed via `import.meta.env` in the application code.

### 2. Key Files and Their Purpose

#### Supabase Client (`src/lib/supabase.ts`)

This file establishes and exports the connection to your Supabase project:

```typescript
import { createClient } from "@supabase/supabase-js";
import type { Database } from "../types/database.types";

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL || "";
const supabaseKey = import.meta.env.VITE_SUPABASE_ANON_KEY || "";

if (!supabaseUrl || !supabaseKey) {
  console.error(
    "Missing Supabase environment variables. Check your .env file."
  );
}

export const supabase = createClient<Database>(supabaseUrl, supabaseKey);
```

#### API Client (`src/lib/api.ts`)

This file configures communication with the FastAPI backend server, handling authentication tokens and error responses:

```typescript
import axios from "axios";

const API_BASE_URL = import.meta.env.VITE_API_URL || "http://localhost:8000";

export const api = axios.create({
  baseURL: API_BASE_URL,
  withCredentials: true,
  headers: {
    "Content-Type": "application/json",
  },
});

// Request interceptor adds auth token to all requests
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem("authToken");
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Response interceptor handles auth errors
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      localStorage.removeItem("authToken");
      localStorage.removeItem("therapistId");
      localStorage.removeItem("therapistData");
      window.location.href = "/login";
    }
    return Promise.reject(error);
  }
);
```

#### Database Types (`src/types/database.types.ts`)

This file defines TypeScript types for all database tables and their relationships.

#### Service Files

1. **Report Service (`src/services/reportService.ts`)**

   - Handles storing and retrieving Gemini AI outputs in the database
   - Uses a flexible JSON approach to store any format returned by Gemini
   - Adds minimal metadata to the stored output

2. **Client Service (`src/services/clientService.ts`)**

   - Manages client data operations (create, read, update)
   - Handles relationships between clients and profiles

3. **Session Service (`src/services/sessionService.ts`)**

   - Manages therapy sessions and scheduling
   - Retrieves detailed session information including reports

4. **Progress Service (`src/services/progressService.ts`)**
   - Tracks treatment goals and progress metrics
   - Records and retrieves progress data for clients

### 3. Database Schema

The following tables are defined in Supabase:

- `therapists` - Therapist login and profile information
- `clients` - Basic client information
- `client_profiles` - Extended client details
- `sessions` - Therapy session records
- `session_reports` - Reports generated by Gemini AI
- `scribbled_notes` - Informal notes from sessions
- `schedules` - Appointment scheduling
- `treatment_goals` - Client treatment objectives
- `progress_tracker` - Client progress metrics

## Storing Gemini AI Outputs

### JSON Storage Approach

The key advantage of our implementation is that we store Gemini AI outputs directly as JSON in the database:

1. **Flexibility**: Accepts any JSON structure returned by Gemini without transformation
2. **Future-proofing**: No need to modify the database schema if Gemini's output format changes
3. **Data preservation**: No information is lost in translation

```typescript
// Example from reportService.ts
export async function processAudioWithGemini(
  audioData: Blob,
  sessionId: string,
  reportType: ReportType,
  apiKey: string
) {
  try {
    // Send audio to FastAPI backend for processing with Gemini
    const response = await fetch(
      `${import.meta.env.VITE_API_URL}/api/process-audio`,
      {
        method: "POST",
        body: formData,
      }
    );

    // Get processed output from Gemini
    const geminiOutput = await response.json();

    // Add metadata to the output
    const enhancedOutput = {
      ...geminiOutput,
      meta: {
        timestamp: new Date().toISOString(),
        requestedFormat: reportType,
        processed: true,
      },
    };

    // Store the output directly as JSON in the database
    await saveSessionReport(sessionId, reportType, enhancedOutput);

    return enhancedOutput;
  } catch (error) {
    console.error("Error in Gemini processing:", error);
    throw error;
  }
}
```

### Accessing Report Data

When retrieving reports, you'll get the complete JSON object that was stored. This gives you maximum flexibility in displaying the information:

```typescript
// Get all reports for a client
const reports = await getClientReports(clientId);

// Display the report content based on what's available
reports.forEach((session) => {
  if (session.session_reports?.length > 0) {
    const reportContent = session.session_reports[0].content;

    // Access metadata added by our service
    if (reportContent.meta) {
      console.log("Created:", reportContent.meta.timestamp);
      console.log("Report type:", reportContent.meta.requestedFormat);
    }

    // Access whatever properties Gemini returned
    if (reportContent.summary) {
      console.log("Summary:", reportContent.summary);
    }

    // You can use the helper function to detect common formats
    const format = detectReportFormat(reportContent);
    console.log("Detected format:", format);

    // Since we're storing raw Gemini output, the exact properties
    // will depend on what Gemini returns - access them directly
    Object.keys(reportContent).forEach((key) => {
      // Skip metadata
      if (key !== "meta") {
        console.log(`${key}:`, reportContent[key]);
      }
    });
  }
});
```

## Usage Examples

### Creating a New Session and Processing Audio

```typescript
import { createSession } from '../services/sessionService';
import { processAudioWithGemini } from '../services/reportService';

// First, create a new session
const newSession = await createSession(clientId, {
  sessionDate: new Date().toISOString(),
  sessionType: "SOAP"
});

// Then process audio recording with Gemini
const audioBlob = /* get audio recording */;
const result = await processAudioWithGemini(
  audioBlob,
  newSession.id,
  "SOAP",
  "your-gemini-api-key"
);

console.log("Processing complete:", result);
```

### Displaying Session Reports

```typescript
import { getClientSessions } from "../services/sessionService";
import { detectReportFormat } from "../services/reportService";

// Get all sessions for a client
const sessions = await getClientSessions(clientId);

// Display sessions and their reports
sessions.forEach((session) => {
  console.log(
    `Session: ${new Date(session.session_date).toLocaleDateString()}`
  );

  if (session.session_reports?.length > 0) {
    const report = session.session_reports[0];
    const content = report.content;

    // Detect the format to adjust display
    const format = detectReportFormat(content);

    switch (format) {
      case "SOAP":
        console.log("Subjective:", content.subjective);
        console.log("Objective:", content.objective);
        console.log("Assessment:", content.assessment);
        console.log("Plan:", content.plan);
        break;

      case "BIRP":
        console.log("Behavior:", content.behavior);
        console.log("Intervention:", content.intervention);
        console.log("Response:", content.response);
        console.log("Plan:", content.plan);
        break;

      case "DAP":
        console.log("Data:", content.data);
        console.log("Assessment:", content.assessment);
        console.log("Plan:", content.plan);
        break;

      default:
        // For generic format, display whatever is available
        if (content.summary) {
          console.log("Summary:", content.summary);
        } else {
          console.log("Report content:", content);
        }
    }
  }
});
```

## Testing the Integration

### 1. Create Database Tables

Run this SQL script in the Supabase SQL Editor to create all required tables:

```sql
-- THERAPISTS LOGIN
create table therapists (
    id uuid primary key default gen_random_uuid(),
    email text unique not null,
    password_hash text not null,
    name text,
    created_at timestamp default now()
);

-- CLIENTS
create table clients (
    id uuid primary key default gen_random_uuid(),
    therapist_id uuid references therapists(id) on delete cascade,
    full_name text not null,
    date_of_birth date,
    gender text,
    created_at timestamp default now()
);

-- Other table definitions as provided...
```

### 2. Insert Test Data

Use the SQL script provided earlier to insert test data, or create a simple test function to verify your setup:

```typescript
async function testSupabaseConnection() {
  try {
    // First create a test therapist
    const { data: therapist, error: therapistError } = await supabase
      .from("therapists")
      .insert({
        email: "test@example.com",
        password_hash: "test_hash",
        name: "Test User",
      })
      .select()
      .single();

    if (therapistError) throw therapistError;
    console.log("Test therapist created:", therapist);

    // Then create a test client
    // ... and so on
  } catch (error) {
    console.error("Test failed:", error);
  }
}
```

## Troubleshooting

### Common Issues

1. **Environment Variables Missing**

   - Ensure `.env` file exists with correct Supabase URL and key

2. **Authentication Issues**

   - Check that the token is properly set in localStorage
   - Verify the token is being included in request headers

3. **Database Errors**

   - Use Supabase dashboard to check for constraint violations or RLS issues
   - Test queries directly in the Supabase SQL editor

4. **Data Typing Issues**
   - Make sure your TypeScript types match the actual database schema
   - Check that JSON data is properly formatted before storage

## Next Steps

1. **Migrate Mock Data**: Replace all mock data in the `/src/data` folder with real database calls
2. **Add RLS Policies**: Implement Row Level Security for data protection
3. **Implement Realtime**: Use Supabase's realtime features for collaborative features

---

For questions or issues, refer to the [Supabase documentation](https://supabase.com/docs) or contact the PsyPlex development team.
